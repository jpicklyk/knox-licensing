# Use Case Params Simplification Plan

**Status:** ✅ COMPLETE
**Created:** 2026-01-30
**Related Task:** #3 - Simplify use case Params classes

## Overview

This plan documents the investigation and proposed simplification of use case `Params` class patterns across the knox-core, knox-enterprise, and knox-tactical modules.

## Current State Analysis

### Params Pattern Types Identified

| Pattern | Type | Count | Description |
|---------|------|-------|-------------|
| A | `Unit` | ~10 | No parameters needed |
| B | Primitive | ~21 | Direct Boolean, Int, String |
| C | Nested Params | ~37 | Inner class wrapping values |
| D | DTO/Domain | ~8 | Reusing existing types |
| E | Reflection | ~2 | Dynamic method invocation |

### Key Issues

1. **Inconsistent single-param wrapping** - Some use cases wrap single primitives in Params classes unnecessarily
2. **Convenience invoke duplication** - Most Params-based use cases duplicate invoke overloads
3. **DTO underutilization** - Existing DTOs sometimes ignored in favor of new Params classes

## KSP Policy Generation Compatibility

### Constraint: Empty Constructors Required

KSP generates policy components before Hilt runs:

```kotlin
// Generated by ComponentGenerator.kt
class AutoCallPickupPolicyComponent : PolicyComponent<AutoCallPickupState> {
    private val policyImpl: AutoCallPickupPolicy = AutoCallPickupPolicy()  // Empty constructor
}
```

Policies instantiate use cases the same way:

```kotlin
class AutoCallPickupPolicy {
    private val getUseCase = GetAutoCallPickupStateUseCase()  // Empty constructor
    private val setUseCase = SetAutoCallPickupStateUseCase()
}
```

### Compatibility Verified

The proposed simplifications are **fully compatible** because:

1. **KSP generation unaffected** - Only cares about policy class constructors
2. **Policy → Use Case calls work identically** - Just changes `useCase(Params(x))` to `useCase(x)`
3. **Empty constructors preserved** - Params simplification doesn't affect constructors

### Ideal Pattern (Already in Use)

```kotlin
// GetAutoCallPickupStateUseCase - Uses Unit
class GetAutoCallPickupStateUseCase: SuspendingUseCase<Unit, AutoCallPickupDto>()

// SetAutoCallPickupStateUseCase - Uses DTO directly
class SetAutoCallPickupStateUseCase: SuspendingUseCase<AutoCallPickupDto, Unit>()
```

## Recommended Pattern by Parameter Count

| Params | Pattern | Example |
|--------|---------|---------|
| 0 | `Unit` | `SuspendingUseCase<Unit, Result>` |
| 1 | Direct type | `SuspendingUseCase<Boolean, Unit>` |
| 2+ | Nested `data class` or DTO | `SuspendingUseCase<Params, Unit>` |

## Use Cases to Simplify

### Single-Field Params → Direct Type (20 use cases)

#### knox-enterprise (7 use cases)

| Use Case | Current | Simplified |
|----------|---------|------------|
| `AllowUsbHostStorageUseCase` | `Params(val allow: Boolean)` | `Boolean` |
| `AllowOtaUpgradeUseCase` | `Params(val enable: Boolean)` | `Boolean` |
| `SetUsbExceptionListUseCase` | `Params(val usbClassList: Int)` | `Int` |
| `AllowFirmwareRecoveryUseCase` | `Params(val enable: Boolean)` | `Boolean` |
| `SetCCModeUseCase` | `Params(val enable: Boolean)` | `Boolean` |
| `IsFirmwareRecoveryAllowedUseCase` | `Params(val showMsg: Boolean)` | `Boolean` |
| `GetAttestationBlobUseCase` | `Params(val nonce: String)` | `String` |

#### knox-tactical (13 use cases)

| Use Case | Current | Simplified |
|----------|---------|------------|
| `SetWlan0MtuUseCase` | `Params(val mtu: Int)` | `Int` |
| `SetRamPlusStateUseCase` | `Params(val disable: Boolean)` | `Boolean` |
| `EnableRandomizedMacAddressUseCase` | `Params(val enable: Boolean)` | `Boolean` |
| `SetLockscreenTimeoutUseCase` | `Params(val seconds: Int)` | `Int` |
| `EnableTcpDumpUseCase` | `Params(val command: String)` | `String` |
| `Disable5gBandLockingUseCase` | `Params(val simSlotId: Int?)` | `Int?` |
| `SetExtraBrightnessUseCase` | `Params(val enable: Boolean)` | `Boolean` |
| `SetElectronicSimEnabledUseCase` | `Params(val enable: Boolean)` | `Boolean` |
| `GetPLMNAllowedListUseCase` | `Params(val simSlotId: Int)` | `Int` |
| `RemovePackageFromUsbHostWhiteListUseCase` | `Params(val appIdentity: AppIdentityData)` | `AppIdentityData` |
| `GetBandLockingStateUseCase` | `Params(val simSlotId: Int?)` | `Int?` |
| `Get5gBandLockingUseCase` | `Params(val simSlotId: Int?)` | `Int?` |
| `Get5gNrModeUseCase` | `Params(val simSlotId: Int?)` | `Int?` |

### Multi-Field Params → Keep As Is (17 use cases)

These have 2+ fields and should retain their Params classes:

#### knox-enterprise
- `SetBrightnessUseCase.Params(enable: Boolean, level: Int)`
- `InstallCaCertificateUseCase.Params(keystore, certificateType, data, alias, password)`

#### knox-tactical
- `ExecuteAsyncIpsecXfrmCommandUseCase.Params(command, callback)`
- `DisableBandLockingUseCase.Params(band, simSlotId)`
- `AddAutoCallNumberUseCase.Params(phoneNumber, priority, answerMode)`
- `AddPackageToUsbHostWhiteListUseCase.Params(enable, appIdentity)`
- `SetHdmPolicyUseCase.Params(policy, reboot)`
- `ConfigureEthernetInterfaceAltUseCase.Params(interfaceName, useDhcp, ipAddress, netmask, dnsAddressList, defaultRouter)`
- `AddIpAddressToEthernetInterfaceUseCase.Params(...)`
- `DeleteIpAddressFromEthernetInterfaceUseCase.Params(...)`
- `GetMacAddressForInterfaceUseCase.Params(...)`
- `GetEthernetInterfaceNameForMacAddressUseCase.Params(...)`
- `SetEthernetAutoConnectionAltUseCase.Params(...)`
- `GetMacAddressViaAidlUseCase.Params(...)`
- `ListIpAddressesUseCase.Params(...)`
- `TestSetEthernetConfigurationsUseCase.Params(...)`
- `TestSetEthernetConfigurationsMultiDnsUseCase.Params(...)`

## Implementation Steps

### Phase 1: knox-enterprise Simplification ✅ COMPLETE

- [x] `AllowUsbHostStorageUseCase` - Change `Params(Boolean)` to `Boolean`
- [x] `AllowOtaUpgradeUseCase` - Change `Params(Boolean)` to `Boolean`
- [x] `SetUsbExceptionListUseCase` - Change `Params(Int)` to `Int`
- [x] `AllowFirmwareRecoveryUseCase` - Change `Params(Boolean)` to `Boolean`
- [x] `SetCCModeUseCase` - Change `Params(Boolean)` to `Boolean`
- [x] `IsFirmwareRecoveryAllowedUseCase` - Change `Params(Boolean)` to `Boolean`
- [x] `GetAttestationBlobUseCase` - Change `Params(String)` to `String`
- [x] No policy classes needed updating (tests use convenience invoke pattern)
- [x] Build verified - no regressions

### Phase 2: knox-tactical Simplification ✅ COMPLETE

- [x] `SetWlan0MtuUseCase` - Change `Params(Int)` to `Int`
- [x] `SetRamPlusStateUseCase` - Change `Params(Boolean)` to `Boolean`
- [x] `EnableRandomizedMacAddressUseCase` - Change `Params(Boolean)` to `Boolean`
- [x] `SetLockscreenTimeoutUseCase` - Change `Params(Int)` to `Int`
- [x] `EnableTcpDumpUseCase` - Change `Params(String)` to `String`
- [x] `Disable5gBandLockingUseCase` - Change `Params(Int?)` to `Int?`
- [x] `SetExtraBrightnessUseCase` - Change `Params(Boolean)` to `Boolean`
- [x] `SetElectronicSimEnabledUseCase` - Change `Params(Boolean)` to `Boolean`
- [x] `GetPLMNAllowedListUseCase` - Change `Params(Int)` to `Int`
- [x] `RemovePackageFromUsbHostWhiteListUseCase` - Change `Params(AppIdentityData)` to `AppIdentityData`
- [x] `GetBandLockingStateUseCase` - Change `Params(Int?)` to `Int?`
- [x] `Get5gBandLockingUseCase` - Change `Params(Int?)` to `Int?`
- [x] `Get5gNrModeUseCase` - Change `Params(Int?)` to `Int?`
- [x] Fixed test file using named parameter syntax (PLMNAllowedListTests.kt)
- [x] Build verified - no regressions

### Phase 3: Documentation ✅ COMPLETE

- [x] Updated CLAUDE.md with "Use Case Parameter Patterns" section
- [x] Added comprehensive KDoc examples to `UseCase` interface
- [x] Added comprehensive KDoc examples to `SuspendingUseCase` abstract class
- [x] Documented parameter naming convention (`params` to avoid warnings)

## Example Transformation

### Before

```kotlin
class SetExtraBrightnessUseCase: SuspendingUseCase<SetExtraBrightnessUseCase.Params, Unit>() {
    data class Params(val enable: Boolean)

    private val settingsManager = CustomDeviceManager.getInstance().settingsManager

    suspend operator fun invoke(enable: Boolean): UnitApiCall {
        return invoke(Params(enable))
    }

    override suspend fun execute(params: Params): ApiResult<Unit> {
        val result = if(params.enable) {
            settingsManager.setExtraBrightness(CustomDeviceManager.ON)
        } else {
            settingsManager.setExtraBrightness(CustomDeviceManager.OFF)
        }
        return when (result) {
            CustomDeviceManager.SUCCESS -> ApiResult.Success(Unit)
            CustomDeviceManager.ERROR_NOT_SUPPORTED -> ApiResult.NotSupported
            else -> ApiResult.Error(DefaultApiError.UnexpectedError("Unknown error occurred"))
        }
    }
}
```

### After

```kotlin
class SetExtraBrightnessUseCase: SuspendingUseCase<Boolean, Unit>() {
    private val settingsManager = CustomDeviceManager.getInstance().settingsManager

    override suspend fun execute(enable: Boolean): ApiResult<Unit> {
        val result = if(enable) {
            settingsManager.setExtraBrightness(CustomDeviceManager.ON)
        } else {
            settingsManager.setExtraBrightness(CustomDeviceManager.OFF)
        }
        return when (result) {
            CustomDeviceManager.SUCCESS -> ApiResult.Success(Unit)
            CustomDeviceManager.ERROR_NOT_SUPPORTED -> ApiResult.NotSupported
            else -> ApiResult.Error(DefaultApiError.UnexpectedError("Unknown error occurred"))
        }
    }
}
```

### Policy Call Change

```kotlin
// Before
setUseCase(SetExtraBrightnessUseCase.Params(enable = true))

// After
setUseCase(true)
```

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Breaking policy callers | Medium | Search for all usages before changing |
| Test failures | Low | Run full test suite after each phase |
| Merge conflicts | Low | Complete in focused PRs per module |

## Success Criteria

1. All single-field Params classes converted to direct types
2. All tests pass
3. Build succeeds with no KSP/Hilt errors
4. Policy framework continues to work correctly

## Notes

- The `AutoCallPickup*` use cases are already following the ideal pattern and serve as the reference implementation
- Multi-field Params classes provide value by grouping related parameters and should be kept
- Consider creating a lint rule to enforce the pattern going forward
